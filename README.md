# WokAsyncMessageHandler

Async message producer to use with wok >= 0.4.4  
Handle producer part and consumer part.  
Include mix task to generate ecto migrations for messages and partitions.  
Include mix task to generate serializer for ecto schema (your "model").  
Include mix task to generate messages controllers for ecto schema. (consumer aprt of the lib)   

The **WokAsyncMessageHandler.Bases.Ecto** module when used (with the 'use' macro)
in another module allows to register messages in a table (autogenerated) of your PG database.  
This table is used as a queue for wok to send your messages asynchronously to your message broker (kafka).
Using it in a SQL transaction in your code garanties your messages reflect exactly
your DB state when they are written to BD and that they will be sent to your message broker later,
 no matter what happens, by wok producer process.  
When a message is registered, its id (autoincremented column by PG, send in wok message headers as "message_id" param)
lets your consumers, when they receive the message, know if they already have processed this message.  
It's an "at least once message dispatch, at least once message delivered and exactly once message processed" flow.  

The **WokAsyncMessageHandler.MessageControllers.Base** module allows to define messages controllers in your application to consume messages.  
Thanks to message_id header, it prevents to process multiple times the same message.  
It natively consume ```created``` (new record in db), ```updated``` (insert or update a record in db) and ```destroyed``` (delete a record from db) event.  
Look below for more information about it.  

## Installation

in your mix.exs file, include in deps :
```
[...
  {:wok_async_message_handler, git: "git@gitlab.botsunit.com:msaas/wok_async_message_handler.git"},
...]
```

generate required files:
```
mix wok_async_message_handler.init
```
This will create 2 ecto migrations, a serializers folder and a default message handler:
- WokAsyncMessageHandler.Models.EctoProducerMessage to store messages to send (3 fields : topic, partition, blob)
- WokAsyncMessageHandler.Models.StoppedPartition to store stopped partition (when errors occur) and allow the connection to a monitoring system for example
- lib/message_serializers directory to store message serializers for ecto schema (see below for generation)
- lib/message_controllers directory to store message controllers for ecto schema (see below for generation)
- lib/services/wok_async_message_handler.ex where a default message handler is generated for you (YOU NEED TO PARAMETER THIS!!!!! DON'T FORGET!!!)

if need, create your database (mix ecto.create), then run :
```
mix ecto.migrate
```

add to your config file :
```
config :wok, producer: [handler: MyApp.Services.WokAsyncMessageHandler, frequency: 100, number_of_messages: 1000]
```
(replace MyApp.Services.WokAsyncMessageHandler by your generated handler name)

create a serializer for your ecto schema MyAppEctoSchema (example : User Or Any resource mapped to db as a "model"):
```
mix wok_async_message_handler.serializer --schema MyAppEctoSchema
```
Edit the generated serializer to add fields to serialization methods and customize "message_route" and "partition_key" functions to fit your needs. (see below for for detail of a serializer)  

and now you can call functions in your code (be sure to add them always in a SQL transaction):
```
{:ok, message} = MyApp.Services.WokAsyncMessageHandler
                 .create_and_add_rt_notification_to_message_queue(%{session_id: "my_session_id"})
...
my_app_ecto_schema = MyApp.Datastores.PG.get(MyApp.MyAppEctoSchema, 1)
{:ok, message} = MyApp.Services.WokAsyncMessageHandler
                 .create_and_add_message_to_message_queue(my_app_ecto_schema, :created, "my_topic")
```

## test

create a local file in config directory to configure database access (duplicate config/local.exs.example if ok)
```
MIX_ENV=test mix wok_async_message_handler.init
MIX_ENV=test mix ecto.drop
MIX_ENV=test mix ecto.create
MIX_ENV=test mix ecto.migrate
mix espec
MIX_ENV=tests mix wok_async_message_handler.controller --schema MyAppEctoSchema #test controller generation
MIX_ENV=tests mix wok_async_message_handler.serializer --schema MyAppEctoSchema #test serializer generation
```
don't forget to clean your tests after (generated migrations files in priv/repo/migrations)  


## messages controllers

To generate a messages controller for a resource, use mix task :
```
mix wok_async_message_handler.controller --schema MyAppEctoSchema
```
Don't forget to use mix and ecto to generate a schema and a migration file for this resource.  
Go to created file and edit it as you need.  
After that, you need to map your wok handlers config to your controller and it will start consuming messages.  
By default, this consumer will consume : "created", "destroyed" and "updated" events.  
If you want you can add method in your controller to handle cutom events.  


You can use hooks in your controller. Just redefine these methods in your controller:  

* ```def on_update_before_update(attributes), do: attributes```
* ```def on_update_after_update(ecto_schema), do: {:ok, ecto_schema}```
* ```def on_destroy_before_delete(attributes), do: attributes```
* ```def on_destroy_after_delete(ecto_schema), do: {:ok, ecto_schema}```

**before** are called before the database update/delete and take the payload from the event as map.  
It returns a map used as the schema data for sql query.  
(The default hook as you can see returns just what's inside the payload = it does nothing)  
**after** are called just after the database update/delete and take the ecto schema returned by the query call as argument.  
It returns {:ok, ecto_schema}. If something else is returned, the transaction is canceled and the consumer will stop consuming 
this partition. It will be recorded in ```stopped_partitions``` table.

"created" code in mpdule is just an alias of "updated" for now.  

Finally, you can rewrite create/1, update/1, destroy/1 if you need to have some specific functions.  
Theses methods just take the row "event" and must return ```Wok.Message.no_reply()```  

## serializers

A serializer has multiple functions :
- **message_versions** : returns the list of supported messages serialization versions.  
You should not have more than 2 (or exceptionnaly 3) supported versions.  
When you want to generate a message, the handler will serialize all versions, using the serialization method for the event.  

- **created|updated|destroyed|[your event]** :  
serialization methods for events.
It takes two params (your ecto schema with data, and a version).  
You just need to define the map to return for json serialization.  

- **partition_key** :
THIS MUST RETURN A STRING.  
Returns the partition key for kafka. Often your ID or MASTER_ID.  
If you return an integer, it will be send to this partition number, but this behavior is not wanted here.  

- **message_route** :
the 'to' field in your message.  

## create_and_add_rt_notification_to_message_queue/1

### this method is deprecated. Use WokAsyncMessageHandler.Helpers.RealTimeMessages.build_and_store/3 instead

This method sends a realtime message. **This is an opinionated method.**  
It just generates a message in queue table to "#{@producer_name}/real_time/notify" (@producer_name defined in your handler when you run the "init")  
If it doesn't fit your needs, rewrite a method in your handler.  
It takes a map as argument.  
THE FIRST VALUE of this map will be used for kafka partition_key.  
IT DOESN'T HANDLE VERSIONING OF RT MESSAGES FOR NOW.  

If you need to send messages to a session_id, call :
```
create_and_add_rt_notification_to_message_queue(%{session_id: my_session_id})
```

The whole map will be merged into message :payload value with the %{source: @producer_name} map.  
IE, create_and_add_rt_notification_to_message_queue(%{session_id: my_session_id}) will have a payload field with %{session_id: my_session_id, source: @producer_name}  
Since a merge in elixir reorders map in alpabetical order, pay attention to the partition key (first value of the map).  

This method accept an options (map) as second param. You can add these fields in this map:
* ```:pkey``` : atom, let you specify which key from the first map you want to use get the value for partition key.  
* ```:from``` : string, let you specify a custom ```from``` for the message.  
* ```:to``` : string, let you specify a custom ```to``` for the message.  

## helpers

### WokAsyncMessageHandler.Helpers.RealTimeMessages

* build_and_store/3  
Use this method when you want to send realtime messages.  
It will build and store the message to send in your database with these default fields:
* topic: @realtime_topic value from handler
* partition_key: THE FIRST VALUE of the data map (see below for more info)
* from: producer_name value of handler
* to: "#{handler.producer_name}/real_time/notify"  

The message will be then send later by the producer.  

You can redefine defaul fields if you need:
```
WokAsyncMessageHandler.Helpers.RealTimeMessages.build_and_store(
  MyApp.Services.WokAsyncMessageHandler,  # message handler to use to build and store message
  %{data1: value1, data2: value2...}, # a map where you specify your payload's data
  %{pkey: :data2, from: "my_from", to: "my_custom_to"} #optionnal and each key is optionnal too
)
```
Since a merge in elixir reorders map in alpabetical order, pay attention to the partition key (first value of the map) if you don't redefine it in the second map.  

THIS METHOD DOESN'T HANDLE VERSIONING OF RT MESSAGES FOR NOW.  

Example: If you need to send messages to a session_id, call :
```
WokAsyncMessageHandler.Helpers.RealTimeMessages.build_and_store(%{session_id: my_session_id})
```
The whole map will be merged into message :payload value. If you don't specify a "source" field, it will be added to your payload with @producer_name as value.  
IE, ```build_and_store(%{session_id: my_session_id})``` will have a payload field with ```%{session_id: my_session_id, source: @producer_name}```  

This method accept an options (map) as second param. You can add these fields in this map:
* ```:pkey``` : atom, let you specify which key from the first map you want to use get the value for partition key.  
* ```:from``` : string, let you specify a custom ```from``` for the message.  
* ```:to``` : string, let you specify a custom ```to``` for the message.  

### WokAsyncMessageHandler.Helpers.Messages

* build_and_store/4  

```
WokAsyncMessageHandler.Helpers.Messages.build_and_store(
  MyApp.Services.WokAsyncMessageHandler,  # message handler to use to build and store message
  ecto_schema,  # your data / model / ecto_schema
  event, # the event you want to produce. Usually :created | :updated | :destroyed
  topic, # topic where you want to send the message
```
Use this method when you want to send a message/event in your broker.  
It will build and store the message  in your database with the parameters defined in the handler.  
